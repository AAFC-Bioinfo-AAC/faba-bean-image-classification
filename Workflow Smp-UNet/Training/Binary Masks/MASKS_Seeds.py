#hkb
#__author__="harpreet kaur bargota"
#__email__="harpreet.bargota@agr.gc.ca"
#__Project__="Faba bean Feature extraction pipeline (Step2)"

#References: 
#SAM 2: Segment Anything in Images and Videos:https://github.com/facebookresearch/sam2
#Reference paper: https://ai.meta.com/research/publications/sam-2-segment-anything-in-images-and-videos/

#Feature extraction: 
#scikit-image library for image processing: Stéfan van der Walt, Johannes L. Schönberger, Juan Nunez-Iglesias, François Boulogne, Joshua D. Warner, Neil Yager, Emmanuelle Gouillart, Tony Yu and the scikit-image contributors. scikit-image: Image processing in Python. PeerJ 2:e453 (2014) https://doi.org/10.7717/peerj.453
#https://scikit-image.org/docs/stable/api/skimage.measure.html


# This script saves the binary masks of faba bean seeds from Step1 into an output directory

#import the libraries required for analysis

import argparse
import pandas as pd
import seaborn as sns
import numpy as np
import cv2
import os
import glob
import matplotlib.pyplot as plt
#from scipy.stats import (pearsonr, ttest_rel, f_oneway, spearmanr, shapiro, levene, wilcoxon, kruskal, skew, kurtosis )
import warnings
warnings.filterwarnings(action='ignore')
from skimage import measure
from skimage.measure import label, regionprops, regionprops_table
from collections import Counter


#Function to define the shape of beans based on the values of shapefactor1,2,3,4 from faba bean images
def classify_shape(row):
    """
        Identifies the shape of beans based on the shapefactors.

        Arguments:
          row: the data for each seed. 

        Returns: str: shape of beans.    
        
    """
    if row['Shapefactor1']<=0.5:
           shape1='Elongated'
    else:
            shape1='Compact'
            
    if row['Shapefactor2']<=0.5:
        shape2='Oval'
    else:
        shape2='Circular'
        
    if row['Shapefactor3']>=0.9:
        shape3='Circular'
    else:
        shape3='Elongated'     
        
    if row['Shapefactor4']>=0.9:
        shape4='Ellipse'
    else:
        shape4='Irregular'
        
    return f"{shape1},{shape2},{shape3},{shape4}"



def process_SAMmasks(SAM_masks, output_folder):
        
        """
        Analyzes the data, filters the bean masks, checks the circularity of beans, creates combined binary mask for each image, and saves the binary masks in the output folder. 

        Arguments:
          SAM_masks: The folder containing the subfolders for each image with binary masks and metadata.Expects the
          binary masks in .png format, with pixel values in [0, 255] and a metadata file in .csv format generated by Segmentanything model SAM.
         output_folder: The output folder where the binary masks (.png) will be saved.

         Raises:
        TypeError: If the conditions are not met.
    
        """   


        if not os.path.exists(SAM_masks):
                print(f"Error: SegmentAnything masks folder '{SAM_masks}' does not exist.")
                return
        if not os.path.exists(output_folder):
                os.makedirs(output_folder)
                print(f"Output folder '{output_folder}' created.")
                
                # Create an empty list 
                df_total=[]

                # Loop through each subfolder in the main folder
                for subfolder_name in os.listdir(SAM_masks):
                        subfolder_path = os.path.join(SAM_masks, subfolder_name)
                        
    
                        #create an empty list 
                        df_list=[]
                
             
                        # Check if it's a directory
                        if os.path.isdir(subfolder_path):
                                print(f'Opening subfolder: {subfolder_path}')
                
                                # Open the metadata file for each image
                                csv_file = glob.glob(os.path.join(subfolder_path, '*.csv'))
    
                                # Read the CSV file into a pandas DataFrame
                                df_metadata = pd.read_csv(csv_file[0])                
          
                                # dataframe for coin required for standardization of area, length and width
                                df_metadata_coin = df_metadata[(df_metadata['bbox_x0'] >= 3000) & (df_metadata['area'] >= 200000)]
                
                                # Find the mask of coin
                                Mask_index1= df_metadata_coin.index.tolist()
                                
                                # Since there can be many masks of coin, take the first mask of coin
                                Mask_index=Mask_index1[:1]
                                               
                                # print the index of coin mask
                                print ('Index of coin mask is ', Mask_index)
       
                                # Eliminating the non-specific masks to get the required bean masks 
                                                          
                                conditions = [
                                        (df_metadata['bbox_x0'] <= 2800) & (df_metadata['bbox_y0'] <= 1950), #Colorcard
                                        (df_metadata['bbox_x0'] <= 1900) & (df_metadata['bbox_y0'] >= 4650), #label
                                        (df_metadata['bbox_x0'] <= 4000) & (df_metadata['bbox_y0'] >= 5200), #Scale
                                        (df_metadata['bbox_x0'] >= 3000) & (df_metadata['area'] >= 200000), #coin   
                                        (df_metadata['bbox_x0'] >= 3000) & (df_metadata['bbox_y0'] >= 4400),  # coin  
                                        (df_metadata['area'] <= 5000), # un-specific areas 
                                        (df_metadata['bbox_h'] >= 1900), # duplicate masks 
                                        (df_metadata['bbox_w'] >= 700) ] # duplicate masks

                                # Eliminating the non-specific masks to get the required bean masks
                                for condition in conditions:
                                        df_metadata = df_metadata.drop(df_metadata[condition].index)
    
                                # List of mask filenames (without extensions)
                                mask_filenames=df_metadata.index.to_list()
                                print ("The list of bean masks after removing the non-specific masks are ", mask_filenames)

                                # Initialize the combined mask as None
                                combined_mask = None

                                # Define the circularity threshold
                                circularity_threshold = 0.7
                
                # Loop through the list of mask filenames
                                for mask_filename in mask_filenames:
            
                # Construct the full file path
                                        file_path = os.path.join(subfolder_path, f'{mask_filename}.png')
                                        
                # Load each binary mask as grayscale
                                        mask = cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)
                                        circularity_values=[]

                                        if mask is None:
                                                print(f"Warning: {file_path} not found or couldn't be loaded.")
                                                continue  # Skip if the mask is not found
                                        
                                        # Find contours
                                        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                                        
                                        # Check if any contour satisfies the circularity condition
                                        include_mask = False
                                        for contour in contours:
                                            area = cv2.contourArea(contour) # calculate the area 
                                            perimeter = cv2.arcLength(contour, True) # calculate the perimeter
                                            if perimeter > 0:  # Avoid division by zero
                                                circularity = (4 * np.pi * area) / (perimeter ** 2) # calculate the circularity
                                                circularity_values.append(circularity) # add circularity values in a list
                                                print (" The Circularity is: ", circularity_values)


                                                #check for circularity values 
                                                if circularity > circularity_threshold:
                                                    include_mask = True
                                                    if any(x < 0.5 for x in circularity_values): #check for each circularity value in list
                                                        include_mask = False   # if any value is less than 0.5, discard the mask
                                                    break  # No need to check further contours in this mask
                                        if include_mask:
                                            print(f"Mask {mask_filename} passes circularity check.")

                                            # Add the mask to the combined mask
                                            if combined_mask is None:
                                                combined_mask = mask.copy()
                                            else:
                                                combined_mask = cv2.bitwise_or(combined_mask, mask)
                                        else:
                                            print(f"Mask {mask_filename} does not pass circularity check.")
                    
                                        
                                # Convert the result back to binary
                                _, combined_mask = cv2.threshold(combined_mask, 127, 255, cv2.THRESH_BINARY)
        
                                # Find contours in the binary mask
                                contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

                                # Create a copy of the mask or create a blank canvas to draw the contours on
                                contour_image = cv2.cvtColor(combined_mask, cv2.COLOR_GRAY2BGR)  # Convert to color if needed

                                #    Generate the output file name using the subfolder name for mask
                                output_file_name = f"{subfolder_name}_mask.png"

                                # Construct the full path for saving
                                output_file_path = os.path.join(output_folder, output_file_name)
                                # Save the combined mask to the output folder
                                cv2.imwrite(output_file_path, combined_mask)
                                print(f"Combined binary mask saved at: {output_file_path}")
       

if __name__ == "__main__":
    # Create ArgumentParser object
    parser = argparse.ArgumentParser(description="Process files from input folder to output folder.")

    # Add arguments for input and output folders
    parser.add_argument("SAM_masks", help="Path to the SAM masks")
    parser.add_argument("output_folder", help="Path to the output folder")

    # Parse the command-line arguments
    args = parser.parse_args()

    # Call the process_folders function with provided input and output folders
    process_SAMmasks(args.SAM_masks, args.output_folder)
